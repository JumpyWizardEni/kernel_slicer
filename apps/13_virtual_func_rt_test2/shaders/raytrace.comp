#version 460
#extension GL_EXT_ray_query : require
#extension GL_GOOGLE_include_directive : require

// https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt

struct Lite_Hit
{
  float t;
  int   primId; 
  int   instId;
  int   geomId;
};

#define KGEN_FLAG_RETURN            1
#define KGEN_FLAG_BREAK             2
#define KGEN_FLAG_DONT_SET_EXIT     4
#define KGEN_FLAG_SET_EXIT_NEGATIVE 8
#define KGEN_REDUCTION_LAST_STEP    16

/*
__attribute__((reqd_work_group_size(256, 1, 1)))
__kernel void kernel_RayTrace(
  __global const float4 * rayPosAndNear,
  __global float4 * rayDirAndFar,
  __global Lite_Hit * out_hit,
  __global float2 * out_bars,
  __global uint* kgen_threadFlags,
  __global float4* m_vPos4f,
  __global unsigned int* m_indicesReordered,
  __global struct Interval* m_intervals,
  __global struct BVHNode* m_nodes,
  __global struct TestClass_UBO_Data* ubo,
  const uint kgen_iNumElementsX, 
  const uint kgen_iNumElementsY,
  const uint kgen_iNumElementsZ,
  const uint kgen_tFlagsMask)
*/

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, set = 0) buffer RayPart0 { vec4     rayPosAndNear[]; }; //  __global const float4 * rayPosAndNear
layout(binding = 1, set = 0) buffer RayPart1 { vec4     rayDirAndFar[];  }; //  __global float4 * rayDirAndFar,
layout(binding = 2, set = 0) buffer HitPart1 { Lite_Hit out_hit[];       }; //  __global Lite_Hit * out_hit,
layout(binding = 3, set = 0) buffer HitPart2 { vec2     out_bars[];      }; //  __global float2 * out_bars,
layout(binding = 4, set = 0) buffer Flags    { uint     threadFlags[];   }; //  __global uint* kgen_threadFlags,
layout(binding = 5, set = 0) buffer Geom1    { vec4     m_vPos4f[];      }; //  __global float4* m_vPos4f,
layout(binding = 6, set = 0) buffer Geom2    { uint     m_indReord[];    }; //  __global unsigned int* m_indicesReordered,
layout(binding = 7, set = 0) buffer Geom3    { ivec2    m_intervals[];   }; //  __global struct Interval* m_intervals,
layout(binding = 8, set = 0) buffer Geom4    { vec4     m_nodes[];       }; //  __global struct BVHNode* m_nodes,
layout(binding = 9, set = 0) buffer SelfData { uint     fakeubo[];       }; //  __global struct TestClass_UBO_Data* ubo,

layout(binding = 0, set = 1) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1) buffer Color { uint test_color[]; };

layout( push_constant ) uniform kernelIntArgs
{
  uint iNumElementsX; // const uint kgen_iNumElementsX, 
  uint iNumElementsY; // const uint kgen_iNumElementsY,
  uint iNumElementsZ; // const uint kgen_iNumElementsZ,
  uint tFlagsMask;    // const uint kgen_tFlagsMask)
} kgen;


//Surf unpackRayQuery(rayQueryEXT rayQuery)
//{
//	const int primitiveID = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
//
//	ivec3 index = ivec3(indices.i[3 * primitiveID], indices.i[3 * primitiveID + 1], indices.i[3 * primitiveID + 2]);
//	Vertex v0 = unpackVertex(index.x);
//	Vertex v1 = unpackVertex(index.y);
//	Vertex v2 = unpackVertex(index.z);
//
//	vec3 barycentricCoords = vec3(0.0, rayQueryGetIntersectionBarycentricsEXT(rayQuery, true));
//	barycentricCoords.x = 1.0 - barycentricCoords.y - barycentricCoords.z;
//
//	Surf s;
//	s.normal = normalize(v0.normal * barycentricCoords.x + v1.normal * barycentricCoords.y + v2.normal * barycentricCoords.z);;
//	s.pos = normalize(v0.pos * barycentricCoords.x + v1.pos * barycentricCoords.y + v2.pos * barycentricCoords.z);
//
//	return s;
//}

void main() 
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = gl_GlobalInvocationID.x; 
  if(tid >= kgen.iNumElementsX)
    return;
  if((threadFlags[tid] & kgen.tFlagsMask) != 0) 
    return;

  //const float4 m_lightSphere = ubo->m_lightSphere;
  ///////////////////////////////////////////////////////////////// prolog
  
  const vec4 rayPos = rayPosAndNear[tid];
  const vec4 rayDir = rayDirAndFar[tid] ;

  Lite_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);

  vec3 pixelColor = vec3(0.0f, 0.0f, 1.0f);

  while(rayQueryProceedEXT(rayQuery)) { }

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {
  	//pixelColor = vec3(1.0f, 1.0f, 0.0f);  
  	//Surf s = unpackRayQuery(rayQuery);
  	//vec3 lightVector = vec3(1.0, 1.0, 0.0);
  	//float dot_product = max(dot(lightVector, s.normal), 0.1);
  	//pixelColor *= dot_product;
	test_color[tid] = 0xFFFFFFFF;
  }
  else
  {
  	//pixelColor = mix(vec3(0.99f, 0.83f, 0.5f), vec3(0.25f, 0.5f, 1.0f), abs(direction.y));
	test_color[tid] = 0xFF00FF00;
  }

  bool kgenExitCond = (res.primId != -1); 
  {
    const bool exitHappened = (kgen.tFlagsMask & KGEN_FLAG_SET_EXIT_NEGATIVE) != 0 ? !kgenExitCond : kgenExitCond;
    if((kgen.tFlagsMask & KGEN_FLAG_DONT_SET_EXIT) == 0 && exitHappened)
      threadFlags[tid] = ((kgen.tFlagsMask & KGEN_FLAG_BREAK) != 0) ? KGEN_FLAG_BREAK : KGEN_FLAG_RETURN;
  };

}
