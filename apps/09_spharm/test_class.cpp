#include "test_class.h"
#include "Bitmap.h"
#include <cassert>
#include <algorithm>
#include <array>

using namespace LiteMath;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline float sqr(float x) { return x * x; }

void SphHarm::kernel2D_IntegrateSphHarm(uint32_t* a_data, uint32_t a_width, uint32_t a_height)
{
  //Iterate over height
  for (uint32_t i = 0; i < a_height; ++i) {
    //Iterate over width
    for (uint32_t j = 0; j < a_width; ++j) {
      //Create a direction to texel
      const float phi = (j + 0.5f) / a_width * PI * 2.0f;
      const float theta = (0.5 - (i + 0.5f) / a_height) * PI;
      const float3 direction = float3(std::sin(phi) * std::cos(theta), std::sin(theta), std::cos(phi) * std::cos(theta));
      //Extract color
      const uint32_t texelIdx = i * a_width + j;
      const uint32_t texelData = a_data[texelIdx];
      const float3 color = float3(texelData & 0xFF, (texelData >> 8) & 0xFF, (texelData >> 16) & 0xFF) / 255.0f;
      //Add new coefficients to integration
      coefs[0] += color;
      coefs[1] += color * direction.y;
      coefs[2] += color * direction.z;
      coefs[3] += color * direction.x;
      coefs[4] += color * direction.x * direction.y;
      coefs[5] += color * direction.y * direction.z;
      coefs[6] += color * (2 * direction.z * direction.z - direction.x * direction.x - direction.y * direction.y);
      coefs[7] += color * direction.x * direction.z;
      coefs[8] += color * direction.x * direction.x - direction.y * direction.y;
    }
  }
}

void SphHarm::kernel1D_FinalizeCoeff(uint32_t a_size, uint32_t a_width, uint32_t a_height)
{
  for(uint32_t j=0;j<a_size;j++)
  {
    //Finalize coefficients
    coefs[0] *= 0.5f / std::sqrt(PI);
    coefs[1] *= -0.5f * std::sqrt(3.0f / PI);
    coefs[2] *= 0.5f * std::sqrt(3.0f / PI);
    coefs[3] *= -0.5f * std::sqrt(3.0f / PI);
    coefs[4] *= 0.5f * std::sqrt(15.0f / PI);
    coefs[5] *= -0.5f * std::sqrt(15.0f / PI);
    coefs[6] *= 0.25f * std::sqrt(5.0f / PI);
    coefs[7] *= -0.5f * std::sqrt(15.0f / PI);
    coefs[8] *= 0.25f * std::sqrt(15.0f / PI);
    for (uint32_t i = 0; i < COEFS_COUNT; ++i) {
      coefs[i] /= a_height * a_width;
      coefs[i] *= PI;
    }
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void SphHarm::ProcessPixels(uint32_t* a_data, uint32_t a_width, uint32_t a_height)
{
  kernel2D_IntegrateSphHarm(a_data, a_width, a_height);
  kernel1D_FinalizeCoeff(1, a_width, a_height);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

std::array<LiteMath::float3, 9> process_image_cpu(std::vector<uint32_t>& a_inPixels, uint32_t a_width, uint32_t a_height)
{
  SphHarm integrator;
  std::array<LiteMath::float3, 9> resCoeffs;
  integrator.ProcessPixels(a_inPixels.data(), a_width, a_height);
  integrator.GetCoefficients(resCoeffs.data());
  return resCoeffs;
}
